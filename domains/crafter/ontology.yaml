# =============================================================================
# CRAFTER ONTOLOGY v2 - Palantir-style structure
# =============================================================================
# Restructured to align with Palantir's ontology primitives:
#   - Object Types (entities with typed properties)
#   - Link Types (explicit relationships)
#   - Interfaces (shared capabilities)
#   - Action Types (operations on objects, with preconditions/effects)
# =============================================================================

# -----------------------------------------------------------------------------
# INTERFACES (Shared capabilities across object types)
# -----------------------------------------------------------------------------
interfaces:
  Positionable:
    description: "Any object with a position in the world"
    properties:
      pos: {type: tuple[int, int], required: true}

  Damageable:
    description: "Any object that can take damage and be destroyed"
    properties:
      health: {type: int, min: 0, required: true}
    derived:
      is_dead: "health <= 0"

  Mobile:
    description: "Any object that can move"
    extends: [Positionable]
    properties:
      walkable_materials: {type: list[MaterialType], required: true}
    capabilities: [move]

  Hostile:
    description: "Entities that attack the player"
    extends: [Damageable, Mobile]
    properties:
      damage: {type: int, required: true}
      attack_range: {type: int, required: true}

  Collectable:
    description: "Materials that yield items when collected"
    properties:
      yields: {type: ItemType, required: true}
      requires_tool: {type: ToolType, required: false}
      leaves_behind: {type: MaterialType, required: true}

  Craftable:
    description: "Items that can be crafted"
    properties:
      recipe: {type: dict[ItemType, int], required: true}
      requires_nearby: {type: list[MaterialType], required: true}

# -----------------------------------------------------------------------------
# OBJECT TYPES
# -----------------------------------------------------------------------------
object_types:
  # ---------------------------------------------------------------------------
  # AGENTS
  # ---------------------------------------------------------------------------
  Player:
    description: "The agent-controlled entity"
    implements: [Damageable, Mobile]
    primary_key: player_id  # singleton in this game
    properties:
      health: {type: int, min: 0, max: 9, initial: 9}
      food: {type: int, min: 0, max: 9, initial: 9}
      drink: {type: int, min: 0, max: 9, initial: 9}
      energy: {type: int, min: 0, max: 9, initial: 9}
      pos: {type: tuple[int, int]}
      facing: {type: tuple[int, int], enum: [[-1,0], [1,0], [0,-1], [0,1]]}
      sleeping: {type: bool, initial: false}
      # Internal counters (hidden state)
      _hunger: {type: float, internal: true}
      _thirst: {type: float, internal: true}
      _fatigue: {type: float, internal: true}
      _recover: {type: float, internal: true}
    inventory:
      type: map[ItemType, int]
      max_per_slot: 9

  # ---------------------------------------------------------------------------
  # CREATURES
  # ---------------------------------------------------------------------------
  Zombie:
    description: "Melee hostile that chases player"
    implements: [Hostile]
    primary_key: entity_id
    properties:
      health: {type: int, initial: 5}
      pos: {type: tuple[int, int]}
      damage: {type: int, value: 2}  # or 7 if player sleeping
      damage_sleeping: {type: int, value: 7}
      attack_range: {type: int, value: 1}
      attack_cooldown: {type: int, value: 5}
      chase_range: {type: int, value: 8}
      walkable_materials: [grass, path, sand]

  Skeleton:
    description: "Ranged hostile that shoots arrows"
    implements: [Hostile]
    primary_key: entity_id
    properties:
      health: {type: int, initial: 3}
      pos: {type: tuple[int, int]}
      damage: {type: int, value: 2}  # via arrow
      attack_range: {type: int, value: 5}  # shooting range
      reload_time: {type: int, value: 4}
      walkable_materials: [grass, path, sand]

  Cow:
    description: "Passive creature, food source"
    implements: [Damageable, Mobile]
    primary_key: entity_id
    properties:
      health: {type: int, initial: 3}
      pos: {type: tuple[int, int]}
      walkable_materials: [grass, path, sand]
      drops: {food: 6}

  Arrow:
    description: "Projectile fired by Skeleton"
    implements: [Positionable]
    primary_key: entity_id
    properties:
      pos: {type: tuple[int, int]}
      facing: {type: tuple[int, int]}
      damage: {type: int, value: 2}

  Plant:
    description: "Growable food source"
    implements: [Positionable, Damageable]
    primary_key: entity_id
    properties:
      pos: {type: tuple[int, int]}
      health: {type: int, initial: 1}
      grown: {type: int, initial: 0}
      ripe_threshold: {type: int, value: 300}
    derived:
      is_ripe: "grown >= ripe_threshold"

  # ---------------------------------------------------------------------------
  # MATERIALS (Terrain - modeled as object types for uniformity)
  # ---------------------------------------------------------------------------
  Tile:
    description: "A single terrain tile"
    implements: [Positionable]
    primary_key: [x, y]
    properties:
      pos: {type: tuple[int, int]}
      material: {type: MaterialType}
      object: {type: ObjectType, nullable: true}  # entity on this tile

# -----------------------------------------------------------------------------
# ENUMS / VALUE TYPES
# -----------------------------------------------------------------------------
enums:
  MaterialType:
    values:
      - grass
      - path
      - sand
      - water
      - lava
      - tree
      - stone
      - coal
      - iron
      - diamond
      - table
      - furnace

  ItemType:
    values:
      # Vitals
      - health
      - food
      - drink
      - energy
      # Resources
      - wood
      - stone
      - coal
      - iron
      - diamond
      - sapling
      # Tools
      - wood_pickaxe
      - stone_pickaxe
      - iron_pickaxe
      # Weapons
      - wood_sword
      - stone_sword
      - iron_sword

  ToolType:
    values:
      - wood_pickaxe
      - stone_pickaxe
      - iron_pickaxe

  WeaponType:
    values:
      - wood_sword
      - stone_sword
      - iron_sword

# -----------------------------------------------------------------------------
# LINK TYPES (Explicit relationships)
# -----------------------------------------------------------------------------
link_types:
  # Spatial relationships
  PlayerAt:
    from: Player
    to: Tile
    cardinality: one_to_one
    description: "Player's current position"

  EntityAt:
    from: [Zombie, Skeleton, Cow, Arrow, Plant]
    to: Tile
    cardinality: many_to_one
    description: "Entity's current position"

  # Proximity relationships (computed, not stored)
  PlayerNearby:
    from: Player
    to: [Zombie, Skeleton, Cow, Tile]
    cardinality: one_to_many
    computed: true
    description: "Entities within player's view range"

  # Ownership/containment
  PlayerInventory:
    from: Player
    to: ItemType
    properties:
      quantity: {type: int, min: 0, max: 9}
    description: "Items in player's inventory"

  # Aggression relationships
  Chasing:
    from: [Zombie, Skeleton]
    to: Player
    computed: true
    condition: "distance(from.pos, to.pos) <= from.chase_range"
    description: "Hostile is actively pursuing player"

  # Crafting relationships (static, definitional)
  CraftableAt:
    from: ItemType
    to: MaterialType
    description: "Items craftable near specific materials"
    instances:
      - {from: wood_pickaxe, to: table}
      - {from: stone_pickaxe, to: table}
      - {from: iron_pickaxe, to: [table, furnace]}
      - {from: wood_sword, to: table}
      - {from: stone_sword, to: table}
      - {from: iron_sword, to: [table, furnace]}

  # Tool requirements (static, definitional)
  UnlockedBy:
    from: MaterialType
    to: ToolType
    description: "Materials that require tools to collect"
    instances:
      - {from: stone, to: wood_pickaxe}
      - {from: coal, to: wood_pickaxe}
      - {from: iron, to: stone_pickaxe}
      - {from: diamond, to: iron_pickaxe}

# -----------------------------------------------------------------------------
# ACTION TYPES (Operations with preconditions and effects)
# -----------------------------------------------------------------------------
# These are Palantir-style "governed transactions" but adapted for game context:
# - Preconditions: what must be true to execute
# - Effects: what changes in the world
# - In our case, the "backing system" is the game engine, not a database
# -----------------------------------------------------------------------------
action_types:
  # ---------------------------------------------------------------------------
  # MOVEMENT
  # ---------------------------------------------------------------------------
  Move:
    id: [1, 2, 3, 4]  # move_left, move_right, move_up, move_down
    parameters:
      direction: {type: tuple[int, int], enum: [[-1,0], [1,0], [0,-1], [0,1]]}
    preconditions: []  # always allowed
    effects:
      - set: Player.facing
        to: parameters.direction
      - if: "Tile(Player.pos + direction).material in Player.walkable_materials"
        then:
          - set: Player.pos
            to: "Player.pos + direction"
      - if: "Tile(Player.pos).material == lava"
        then:
          - set: Player.health
            to: 0

  Noop:
    id: 0
    parameters: {}
    preconditions: []
    effects: []  # time still passes (hunger/thirst/etc)

  # ---------------------------------------------------------------------------
  # INTERACTION
  # ---------------------------------------------------------------------------
  Do:
    id: 5
    description: "Context-sensitive interaction with facing tile"
    parameters: {}
    # This is a compound action - effect depends on what's in facing tile
    preconditions: []
    effects:
      - match: "world[Player.pos + Player.facing]"
        cases:
          # Object interactions
          - when: "is Plant and Plant.is_ripe"
            then:
              - increment: Player.inventory.food
                by: 4
              - set: Plant.grown
                to: 0
              - trigger_achievement: eat_plant

          - when: "is Cow"
            then:
              - decrement: Cow.health
                by: Player.damage
              - if: "Cow.health <= 0"
                then:
                  - remove: Cow
                  - increment: Player.inventory.food
                    by: 6
                  - trigger_achievement: eat_cow

          - when: "is Zombie"
            then:
              - decrement: Zombie.health
                by: Player.damage
              - if: "Zombie.health <= 0"
                then:
                  - remove: Zombie
                  - trigger_achievement: defeat_zombie

          - when: "is Skeleton"
            then:
              - decrement: Skeleton.health
                by: Player.damage
              - if: "Skeleton.health <= 0"
                then:
                  - remove: Skeleton
                  - trigger_achievement: defeat_skeleton

          # Material interactions
          - when: "material == water"
            then:
              - increment: Player.inventory.drink
                by: 1
              - set: Player._thirst
                to: 0
              - trigger_achievement: collect_drink

          - when: "material == tree"
            then:
              - set: Tile.material
                to: grass
              - increment: Player.inventory.wood
                by: 1
              - trigger_achievement: collect_wood

          - when: "material == grass"
            then:
              - if: "random() < 0.1"
                then:
                  - increment: Player.inventory.sapling
                    by: 1
                  - trigger_achievement: collect_sapling

          - when: "material == stone and Player.inventory.wood_pickaxe >= 1"
            then:
              - set: Tile.material
                to: path
              - increment: Player.inventory.stone
                by: 1
              - trigger_achievement: collect_stone

          - when: "material == coal and Player.inventory.wood_pickaxe >= 1"
            then:
              - set: Tile.material
                to: path
              - increment: Player.inventory.coal
                by: 1
              - trigger_achievement: collect_coal

          - when: "material == iron and Player.inventory.stone_pickaxe >= 1"
            then:
              - set: Tile.material
                to: path
              - increment: Player.inventory.iron
                by: 1
              - trigger_achievement: collect_iron

          - when: "material == diamond and Player.inventory.iron_pickaxe >= 1"
            then:
              - set: Tile.material
                to: path
              - increment: Player.inventory.diamond
                by: 1
              - trigger_achievement: collect_diamond

  Sleep:
    id: 6
    parameters: {}
    preconditions:
      - "Player.energy < 9"
    effects:
      - set: Player.sleeping
        to: true
    # Wake conditions handled by dynamics

  # ---------------------------------------------------------------------------
  # PLACEMENT
  # ---------------------------------------------------------------------------
  PlaceStone:
    id: 7
    parameters: {}
    preconditions:
      - "Player.inventory.stone >= 1"
      - "Tile(facing).material in [grass, sand, path, water, lava]"
      - "Tile(facing).object == null"
    effects:
      - decrement: Player.inventory.stone
        by: 1
      - set: Tile(facing).material
        to: stone
      - trigger_achievement: place_stone

  PlaceTable:
    id: 8
    parameters: {}
    preconditions:
      - "Player.inventory.wood >= 2"
      - "Tile(facing).material in [grass, sand, path]"
      - "Tile(facing).object == null"
    effects:
      - decrement: Player.inventory.wood
        by: 2
      - set: Tile(facing).material
        to: table
      - trigger_achievement: place_table

  PlaceFurnace:
    id: 9
    parameters: {}
    preconditions:
      - "Player.inventory.stone >= 4"
      - "Tile(facing).material in [grass, sand, path]"
      - "Tile(facing).object == null"
    effects:
      - decrement: Player.inventory.stone
        by: 4
      - set: Tile(facing).material
        to: furnace
      - trigger_achievement: place_furnace

  PlacePlant:
    id: 10
    parameters: {}
    preconditions:
      - "Player.inventory.sapling >= 1"
      - "Tile(facing).material == grass"
      - "Tile(facing).object == null"
    effects:
      - decrement: Player.inventory.sapling
        by: 1
      - create: Plant
        at: facing
      - trigger_achievement: place_plant

  # ---------------------------------------------------------------------------
  # CRAFTING
  # ---------------------------------------------------------------------------
  MakeWoodPickaxe:
    id: 11
    parameters: {}
    preconditions:
      - "Player.inventory.wood >= 1"
      - "nearby(Player.pos, 1).materials contains table"
    effects:
      - decrement: Player.inventory.wood
        by: 1
      - increment: Player.inventory.wood_pickaxe
        by: 1
      - trigger_achievement: make_wood_pickaxe

  MakeStonePickaxe:
    id: 12
    parameters: {}
    preconditions:
      - "Player.inventory.wood >= 1"
      - "Player.inventory.stone >= 1"
      - "nearby(Player.pos, 1).materials contains table"
    effects:
      - decrement: Player.inventory.wood
        by: 1
      - decrement: Player.inventory.stone
        by: 1
      - increment: Player.inventory.stone_pickaxe
        by: 1
      - trigger_achievement: make_stone_pickaxe

  MakeIronPickaxe:
    id: 13
    parameters: {}
    preconditions:
      - "Player.inventory.wood >= 1"
      - "Player.inventory.coal >= 1"
      - "Player.inventory.iron >= 1"
      - "nearby(Player.pos, 1).materials contains table"
      - "nearby(Player.pos, 1).materials contains furnace"
    effects:
      - decrement: Player.inventory.wood
        by: 1
      - decrement: Player.inventory.coal
        by: 1
      - decrement: Player.inventory.iron
        by: 1
      - increment: Player.inventory.iron_pickaxe
        by: 1
      - trigger_achievement: make_iron_pickaxe

  MakeWoodSword:
    id: 14
    parameters: {}
    preconditions:
      - "Player.inventory.wood >= 1"
      - "nearby(Player.pos, 1).materials contains table"
    effects:
      - decrement: Player.inventory.wood
        by: 1
      - increment: Player.inventory.wood_sword
        by: 1
      - trigger_achievement: make_wood_sword

  MakeStoneSword:
    id: 15
    parameters: {}
    preconditions:
      - "Player.inventory.wood >= 1"
      - "Player.inventory.stone >= 1"
      - "nearby(Player.pos, 1).materials contains table"
    effects:
      - decrement: Player.inventory.wood
        by: 1
      - decrement: Player.inventory.stone
        by: 1
      - increment: Player.inventory.stone_sword
        by: 1
      - trigger_achievement: make_stone_sword

  MakeIronSword:
    id: 16
    parameters: {}
    preconditions:
      - "Player.inventory.wood >= 1"
      - "Player.inventory.coal >= 1"
      - "Player.inventory.iron >= 1"
      - "nearby(Player.pos, 1).materials contains table"
      - "nearby(Player.pos, 1).materials contains furnace"
    effects:
      - decrement: Player.inventory.wood
        by: 1
      - decrement: Player.inventory.coal
        by: 1
      - decrement: Player.inventory.iron
        by: 1
      - increment: Player.inventory.iron_sword
        by: 1
      - trigger_achievement: make_iron_sword

# -----------------------------------------------------------------------------
# FUNCTIONS (Computed values / business logic)
# -----------------------------------------------------------------------------
functions:
  Player.damage:
    description: "Player's attack damage based on equipped weapon"
    returns: int
    logic: |
      max(
        1,  # base damage
        2 if Player.inventory.wood_sword >= 1 else 0,
        3 if Player.inventory.stone_sword >= 1 else 0,
        5 if Player.inventory.iron_sword >= 1 else 0
      )

  distance:
    description: "Manhattan distance between two positions"
    parameters:
      a: tuple[int, int]
      b: tuple[int, int]
    returns: int
    logic: "abs(a[0] - b[0]) + abs(a[1] - b[1])"

  nearby:
    description: "Get tiles within distance of position"
    parameters:
      pos: tuple[int, int]
      distance: int
    returns: set[Tile]
    logic: "{Tile(x,y) for x,y in grid if manhattan(pos, (x,y)) <= distance}"

# -----------------------------------------------------------------------------
# DYNAMICS (Autonomous world updates - not player-triggered)
# -----------------------------------------------------------------------------
# These run every game step regardless of player action
# -----------------------------------------------------------------------------
dynamics:
  hunger_tick:
    every: step
    effects:
      - increment: Player._hunger
        by: "0.5 if Player.sleeping else 1.0"
      - if: "Player._hunger > 25"
        then:
          - set: Player._hunger
            to: 0
          - decrement: Player.inventory.food
            by: 1

  thirst_tick:
    every: step
    effects:
      - increment: Player._thirst
        by: "0.5 if Player.sleeping else 1.0"
      - if: "Player._thirst > 20"
        then:
          - set: Player._thirst
            to: 0
          - decrement: Player.inventory.drink
            by: 1

  fatigue_tick:
    every: step
    effects:
      - increment: Player._fatigue
        by: "-1 if Player.sleeping else 1"
      - if: "Player._fatigue > 30"
        then:
          - set: Player._fatigue
            to: 0
          - decrement: Player.inventory.energy
            by: 1
      - if: "Player._fatigue < -10"
        then:
          - set: Player._fatigue
            to: 0
          - increment: Player.inventory.energy
            by: 1

  health_regen_tick:
    every: step
    effects:
      - if: "Player.inventory.food > 0 and Player.inventory.drink > 0 and (Player.inventory.energy > 0 or Player.sleeping)"
        then:
          - increment: Player._recover
            by: "2 if Player.sleeping else 1"
        else:
          - decrement: Player._recover
            by: "0.5 if Player.sleeping else 1"
      - if: "Player._recover > 25"
        then:
          - set: Player._recover
            to: 0
          - increment: Player.inventory.health
            by: 1
      - if: "Player._recover < -15"
        then:
          - set: Player._recover
            to: 0
          - decrement: Player.inventory.health
            by: 1

  wake_check:
    every: step
    condition: "Player.sleeping"
    effects:
      - if: "Player.inventory.energy >= 9"
        then:
          - set: Player.sleeping
            to: false
          - trigger_achievement: wake_up

  zombie_behavior:
    every: step
    for_each: Zombie
    effects:
      - if: "distance(Zombie.pos, Player.pos) <= 8 and random() < 0.9"
        then:
          - move: Zombie
            toward: Player.pos
        else:
          - move: Zombie
            direction: random
      - if: "distance(Zombie.pos, Player.pos) <= 1 and Zombie.cooldown == 0"
        then:
          - decrement: Player.inventory.health
            by: "7 if Player.sleeping else 2"
          - set: Zombie.cooldown
            to: 5
          - if: Player.sleeping
            then:
              - set: Player.sleeping
                to: false

  skeleton_behavior:
    every: step
    for_each: Skeleton
    effects:
      # Complex behavior omitted for brevity - see ontology v1

  plant_growth:
    every: step
    for_each: Plant
    effects:
      - increment: Plant.grown
        by: 1
      - if: "any adjacent entity in [Zombie, Skeleton, Cow]"
        then:
          - decrement: Plant.health
            by: 1
      - if: "Plant.health <= 0"
        then:
          - remove: Plant
